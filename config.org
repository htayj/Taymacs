#+STARTUP: overview
#+TITLE: Taymacs 
#+CREATOR: Taylor Hardy
#+LANGUAGE: en
#+OPTIONS: num:nil
#+ATTR_HTML: :style margin-left: auto; margin-right: auto;

* aknowledgements
this config was based off of uncle daves emacs who i am forever grateful to for allowing me a user friendly entry point to emacs check out uncle daves repo at https://github.com/daedreth/UncleDavesEmacs

* Dependencies 
* Import Manually Installed Packages
#+BEGIN_SRC emacs-lisp
  (let ((default-directory  (concat user-emacs-directory
                                    (convert-standard-filename "lisp/"))))
    (normal-top-level-add-to-load-path '("."))
    (normal-top-level-add-subdirs-to-load-path))
#+END_SRC

* Org
** Common settings

#+BEGIN_SRC emacs-lisp
  (setq org-ellipsis " ")
  (setq org-src-fontify-natively t)
  (setq org-src-tab-acts-natively t)
  (setq org-confirm-babel-evaluate nil)
  (setq org-export-with-smart-quotes t)
  (setq org-src-window-setup 'current-window)
  (add-hook 'org-mode-hook 'org-indent-mode)
#+END_SRC
** org journal
#+BEGIN_SRC emacs-lisp
  (use-package org-journal 
    :straight t
    :defer t
    :custom
    (org-journal-dir "~/notes/journal/")
    (org-journal-date-format "%A, %d %B %Y"))
#+END_SRC
** Syntax highlighting for documents exported to HTML
#+BEGIN_SRC emacs-lisp
  (use-package htmlize
    :straight t)
#+END_SRC

** Line wrapping
#+BEGIN_SRC emacs-lisp
  (add-hook 'org-mode-hook
            '(lambda ()
               (visual-line-mode 1)))
#+END_SRC
** spell checking
#+BEGIN_SRC emacs-lisp
  (add-hook 'org-mode-hook
            '(lambda ()
               (flyspell-mode 1)))
#+END_SRC
** Keybindings
edit the stuff in a src block with proper modes
#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "C-c '") 'org-edit-src-code)
#+END_SRC

** Org Bullets
change astrisks to bullets
#+BEGIN_SRC emacs-lisp
  (use-package org-bullets
    :straight t
    :config
    (add-hook 'org-mode-hook (lambda () (org-bullets-mode))))
#+END_SRC

** FIXME Easy-to-add emacs-lisp template
Hitting tab after an "<el" in an org-mode file will create a template for elisp insertion.
#+BEGIN_SRC emacs-lisp
  (add-to-list 'org-structure-template-alist
               '("el" . "src emacs-lisp\n"))
#+END_SRC

** Exporting options
One of the best things about org is the ability to export your file to many formats.
Here is how we add more of them!

*** latex
#+BEGIN_SRC emacs-lisp
  ;; (when (file-directory-p "/usr/share/emacs/site-lisp/tex-utils")
  ;;   (add-to-list 'load-path "/usr/share/emacs/site-lisp/tex-utils")
  ;;   (require 'xdvi-search))
#+END_SRC

** todo states
#+BEGIN_SRC emacs-lisp
  (setq org-todo-keywords
        '((sequence "TODO(t)" "PLAN(p)" "WAIT(w@)" "|" "DONE(d!)" "CANCELED(c@)" "MISSED(m@)")))
#+END_SRC
** refile into subtrees
#+BEGIN_SRC emacs-lisp
  (setq org-refile-targets '((nil :maxlevel . 9)
                                  (org-agenda-files :maxlevel . 9)))
  (setq org-outline-path-complete-in-steps nil)         ; Refile in a single go
  (setq org-refile-use-outline-path t)                  ; Show full paths for refiling
#+END_SRC
* Operating System
** Window Manager and Desktop Environment
Everything regarding the WM or DE-like functionality is bundled here

*** exwm
The only time I actually had to use comments, this is for ease of removal if you happen to not like exwm.
**** Installation
#+BEGIN_SRC emacs-lisp
  (use-package exwm
    :straight (exwm :type git :host github :repo "emacs-straight/exwm" :files ("*" (:exclude ".git")))
    :config

    ;; necessary to configure exwm manually
    (require 'exwm-config)

    ;; fringe size, most people prefer 1 
    (fringe-mode 3)

    ;; emacs as a daemon, use "emacsclient <filename>" to seamlessly edit files from the terminal directly in the exwm instance
    (server-start)

    ;; this fixes issues with ido mode, if you use helm, get rid of it
    ;;      (exwm-config-ido)

    ;; a number between 1 and 9, exwm creates workspaces dynamically so I like starting out with 1
    (setq exwm-workspace-number 5)

    ;; make x buffers available on all workspaces
    (setq exwm-workspace-show-all-buffers t)
    (setq exwm-layout-show-all-buffers t)

    ;; this is a way to declare truly global/always working keybindings
    ;; this is a nifty way to go back from char mode to line mode without using the mouse
    (exwm-input-set-key (kbd "s-r") #'exwm-reset)
    (exwm-input-set-key (kbd "s-k") #'exwm-workspace-delete)
    (exwm-input-set-key (kbd "s-w") #'exwm-workspace-swap)
    (exwm-input-set-key (kbd "s-n") 'ibuffer)
    (exwm-input-set-key (kbd "s-m") 'next-buffer)
    (exwm-input-set-key (kbd "s-,") 'previous-buffer)
    (exwm-input-set-key (kbd "s-/") 'kill-current-buffer) 

    (exwm-input-set-key (kbd "s-h") 'windmove-left)
    (exwm-input-set-key (kbd "s-j") 'windmove-down)
    (exwm-input-set-key (kbd "s-k") 'windmove-up)
    (exwm-input-set-key (kbd "s-l") 'windmove-right) 
    (exwm-input-set-key (kbd "s-;") 'delete-window) 


    (exwm-input-set-key (kbd "s-s h") 'split-window-right)
    (exwm-input-set-key (kbd "s-s j") 'split-window-below)
    (exwm-input-set-key (kbd "s-s k") 'split-and-follow-horizontally)
    (exwm-input-set-key (kbd "s-s l") 'split-and-follow-vertically)

    ;; the next loop will bind s-<number> to switch to the corresponding workspace
    (dotimes (i 10)
      (exwm-input-set-key (kbd (format "s-%d" i))
                          `(lambda ()
                             (interactive)
                             (exwm-workspace-switch-create ,i))))

    ;; the simplest launcher, I keep it in only if dmenu eventually stopped working or something
    (exwm-input-set-key (kbd "s-&")
                        (lambda (command)
                          (interactive (list (read-shell-command "$ ")))
                          (start-process-shell-command command nil command)))

    ;; an easy way to make keybindings work *only* in line mode
    (push ?\C-q exwm-input-prefix-keys)
    (define-key exwm-mode-map [?\C-q] #'exwm-input-send-next-key)

    ;; simulation keys are keys that exwm will send to the exwm buffer upon inputting a key combination
    (exwm-input--set-simulation-keys
     '(
       ;; movement
       ([?\C-b] . left)
       ([?\M-b] . C-left)
       ([?\C-f] . right)
       ([?\M-f] . C-right)
       ([?\C-p] . up)
       ([?\C-n] . down)
       ([?\C-a] . home)
       ([?\C-e] . end)
       ([?\M-v] . prior)
       ([?\C-v] . next)
       ([?\C-d] . delete)
       ([?\C-k] . (S-end delete))
       ;; cut/paste
       ([?\C-w] . ?\C-x)
       ([?\M-w] . ?\C-c)
       ([?\C-y] . ?\C-v)
       ;; search
       ([?\C-f] . ?\C-f)
       ;; movement
       ([?\M-h] . return)
       ([?\M-m] . return)
       ([?\M-l] . right)
       ([?\M-k] . down)
       ([?\M-j] . left)
       ([?\M-\\] . prior)
       ([?\M-'] . next)))

    ;; this little bit will make sure that XF86 keys work in exwm buffers as well
    (dolist (k '(XF86AudioLowerVolume
                 XF86AudioRaiseVolume
                 XF86PowerOff
                 XF86AudioMute
                 XF86AudioPlay
                 XF86AudioStop
                 XF86AudioPrev
                 XF86AudioNext
                 XF86ScreenSaver
                 XF68Back
                 XF86Forward
                 Scroll_Lock
                 print))
      (cl-pushnew k exwm-input-prefix-keys))

    (require 'exwm-randr)
    (setq exwm-randr-workspace-monitor-plist '(0 "eDP-1" 1 "eDP-1" 2 "HDMI-1"  3 "HDMI-1"  4 "HDMI-1"  5 "HDMI-1"   ))
    (add-hook 'exwm-randr-screen-change-hook
              (lambda ()
                (start-process-shell-command
                 "xrandr" nil "xrandr --output HDMI-1 --mode 1920x1080 --pos 0x0 --rotate normal --output eDP-1 --primary --mode 1920x1200 --pos 1920x300 --rotate normal")))
    (exwm-randr-enable)
    ;; this just enables exwm, it started automatically once everything is ready
    (exwm-enable))'
  ;; (shell-command "picom --config ~/.config/picom.conf -b")
#+END_SRC
*** Fix change workspace not taking focus
https://github.com/ch11ng/exwm/issues/889
#+BEGIN_SRC emacs-lisp
  (setq x-no-window-manager t)
#+END_SRC 
*** TODO exwm-xsettings
*** Multi monitor
#+BEGIN_SRC emacs-lisp
#+END_SRC
*** exwm edit
#+BEGIN_SRC emacs-lisp
  (use-package exwm-edit
    :straight t)
#+END_SRC
*** System tray
#+BEGIN_SRC emacs-lisp
  (require 'exwm-systemtray)
  (exwm-systemtray-enable)
#+END_SRC

*** Launchers
**** dmenu for emacs
#+BEGIN_SRC emacs-lisp
  (use-package dmenu
    :straight t
    :bind
    ("s-SPC" . 'dmenu))
#+END_SRC
*** windows
**** switch-window
switch window uses an ace type jump if more than 2 windows are open
#+BEGIN_SRC emacs-lisp
  (use-package switch-window
    :straight t
    :config
    (setq switch-window-input-style 'minibuffer)
    (setq switch-window-increase 4)
    (setq switch-window-threshold 2)
    (setq switch-window-shortcut-style 'qwerty)
    (setq switch-window-qwerty-shortcuts
          '("a" "s" "d" "f" "j" "k" "l" "i" "o"))
    :bind
    ([remap other-window] . switch-window))
#+END_SRC

**** Following window splits
After you split a window, your focus remains in the previous one.
This annoyed me so much I wrote these two, they take care of it.
#+BEGIN_SRC emacs-lisp
  (defun split-and-follow-horizontally ()
    (interactive)
    (split-window-below)
    (balance-windows)
    (other-window 1))
  (global-set-key (kbd "C-x 2") 'split-and-follow-horizontally)

  (defun split-and-follow-vertically ()
    (interactive)
    (split-window-right)
    (balance-windows)
    (other-window 1))
  (global-set-key (kbd "C-x 3") 'split-and-follow-vertically)
#+END_SRC
*** Dashboard
Dashboard with recent files and projects
#+BEGIN_SRC emacs-lisp
  (use-package dashboard
    :straight t
    :config
    (dashboard-setup-startup-hook)
    (setq dashboard-startup-banner "~/.emacs.d/img/dashLogo.png")
    (setq dashboard-items '((recents  . 5)
                            (projects . 5)))
    (setq dashboard-banner-logo-title "TAYMACS"))
#+END_SRC

*** Modeline
**** Clock
***** Time format
#+BEGIN_SRC emacs-lisp
  (setq display-time-24hr-format nil)
  (setq display-time-format "%H:%M %m/%d")
#+END_SRC

***** Enabling the mode
This turns on the clock globally.
#+BEGIN_SRC emacs-lisp
  (display-time-mode 1)
#+END_SRC
*** screen reader
**** eloud
#+BEGIN_SRC emacs-lisp
  (use-package eloud
    :straight t
    :config
    (setq eloud-espeak-path "/usr/bin/espeak"))
#+END_SRC

*** Diminishing modes
Your modeline is sacred, and if you have a lot of modes enabled, as you will if you use this config,
you might end up with a lot of clutter there, the package =diminish= disables modes on the mode line but keeps
them running, it just prevents them from showing up and taking up space.

*THIS WILL BE REMOVED SOON AS USE-PACKAGE HAS THE FUNCTIONALITY BUILT IN*

Edit this list as you see fit!
#+BEGIN_SRC emacs-lisp
  (use-package diminish
    :straight t
    :init
    (diminish 'which-key-mode)
    (diminish 'linum-relative-mode)
    (diminish 'hungry-delete-mode)
    (diminish 'visual-line-mode)
    (diminish 'subword-mode)
    (diminish 'beacon-mode)
    (diminish 'irony-mode)
    (diminish 'page-break-lines-mode)
    (diminish 'auto-revert-mode)
    (diminish 'rainbow-delimiters-mode)
    (diminish 'editorconfig-mode)
    (diminish 'subl-mode)
    (diminish 'emo-mode)
    (diminish 'org-indent-mode)
    (diminish 'projectile-mode)
    (diminish 'helm-mode)
    (diminish 'company-mode)
    (diminish 'undo-tree-mode)
    (diminish 'ivy-mode)
    (diminish 'flycheck-mode)
    (diminish 'evil-collection-unimpaired-mode)
    (diminish 'yas-minor-mode)
    (diminish 'org-src-mode)
    (diminish 'eldoc-mode)
    (diminish 'coverlay-minor-mode)
    (diminish 'css-in-js-mode)
    (diminish 'rainbow-mode))
#+END_SRC
*** DONE emacs notification system
- State "DONE"       from "TODO"       [2023-01-25 Wed 20:18]
#+BEGIN_SRC emacs-lisp
  (use-package alert
    :straight t
    :init
    (setq alert-default-style 'notifications)) ;using wired-notif
#+END_SRC

** buffer management
*** Always murder current buffer
Doing =C-x k= should kill the current buffer at all times, we have =ibuffer= for more sophisticated thing.
#+BEGIN_SRC emacs-lisp
  (defun kill-current-buffer ()
    "Kills the current buffer."
    (interactive)
    (kill-buffer (current-buffer)))
  (global-set-key (kbd "C-x k") 'kill-current-buffer)
#+END_SRC

*** Kill buffers without asking for confirmation
Unless you have the muscle memory, I recommend omitting this bit, as you may lose progress for no reason when working.
#+BEGIN_SRC emacs-lisp
  (setq kill-buffer-query-functions (delq 'process-kill-buffer-query-function kill-buffer-query-functions))
#+END_SRC

*** Turn switch-to-buffer into ibuffer
I don't understand how ibuffer isn't the default option by now.
It's vastly superior in terms of ergonomics and functionality, you can delete buffers, rename buffer, move buffers, organize buffers etc.
#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "C-x b") 'ibuffer)
#+END_SRC

**** expert-mode
If you feel like you know how ibuffer works and need not to be asked for confirmation after every serious command, enable this as follows.
#+BEGIN_SRC emacs-lisp
  ;;(setq ibuffer-expert t)
#+END_SRC

*** rename eww buffer to title of page
#+BEGIN_SRC emacs-lisp
  (when (fboundp 'eww)
    (defun xah-rename-eww-buffer ()
      "Rename `eww-mode' buffer so sites open in new page.
  URL `http://xahlee.info/emacs/emacs/emacs_eww_web_browser.html'
  Version 2017-11-10"
      (let (($title (plist-get eww-data :title)))
        (when (eq major-mode 'eww-mode )
          (if $title
              (rename-buffer (concat "eww " $title ) t)
            (rename-buffer "eww" t)))))

    (add-hook 'eww-after-render-hook 'xah-rename-eww-buffer))
#+END_SRC

*** Editing with sudo
Pretty self-explanatory, useful as hell if you use exwm.
#+BEGIN_SRC emacs-lisp
  (use-package sudo-edit
    :straight t
    :bind
    ("s-e" . sudo-edit))
#+END_SRC

*** autoname the buffers
#+BEGIN_SRC emacs-lisp
  ;; autoname buffers
  (add-hook 'exwm-update-class-hook
            (lambda ()
              (exwm-workspace-rename-buffer exwm-class-name)))
#+END_SRC

** system admin
#+BEGIN_SRC emacs-lisp
  (use-package helm-system-packages
    :straight t)
#+END_SRC
* Command Completion
** helm
#+BEGIN_SRC emacs-lisp
  (use-package helm
    :straight t
    :bind
    ("C-x C-f" . 'helm-find-files)
    ("C-x C-b" . 'helm-buffers-list)
    ("M-x" . 'helm-M-x)
    :config
    ;; (defun daedreth/helm-hide-minibuffer ()
    ;;   (when (with-helm-buffer helm-echo-input-in-header-line)
    ;;     (let ((ov (make-overlay (point-min) (point-max) nil nil t)))
    ;;       (overlay-put ov 'window (selected-window))
    ;;       (overlay-put ov 'face
    ;;                    (let ((bg-color (face-background 'default nil)))
    ;;                      `(:background ,bg-color :foreground ,bg-color)))
    ;;       (setq-local cursor-type nil))))
    ;; (add-hook 'helm-minibuffer-set-up-hook 'daedreth/helm-hide-minibuffer)

    ;; (setq helm-autoresize-max-height 0
    ;;       helm-autoresize-min-height 40
    ;;       helm-M-x-fuzzy-match t
    ;;       helm-buffers-fuzzy-matching t
    ;;       helm-recentf-fuzzy-match t
    ;;       helm-semantic-fuzzy-match t
    ;;       helm-imenu-fuzzy-match t
    ;;       helm-split-window-in-side-p nil
    ;;       helm-move-to-line-cycle-in-source nil
    ;;       helm-ff-search-library-in-sexp t
    ;;       helm-scroll-amount 8 
    ;;       helm-echo-input-in-header-line t)
    :init
    (helm-mode 1))
  ;; never truncate buffer names
  (setq helm-buffer-max-length nil)
  ;; (require 'helm-config)    
  (helm-autoresize-mode 0)
  ;; (define-key helm-find-files-map (kbd "C-b") 'helm-find-files-up-one-level)
  ;; (define-key helm-find-files-map (kbd "C-f") 'helm-execute-persistent-action)
  #+END_SRC
*** silver searcher helm
  #+BEGIN_SRC emacs-lisp
    (use-package helm-ag
      :straight t)
  #+END_SRC
#+END_SRC
* Configuration
** Visiting the configuration
Quickly edit =~/.emacs.d/config.org=
#+BEGIN_SRC emacs-lisp
  (defun config-visit ()
    (interactive)
    (find-file "~/.emacs.d/config.org"))
  (global-set-key (kbd "C-c e") 'config-visit)
#+END_SRC

** Reloading the configuration
Simply pressing =Control-c r= will reload this file, very handy.
You can also manually invoke =config-reload=.
#+BEGIN_SRC emacs-lisp
  (defun config-reload ()
    "Reloads ~/.emacs.d/config.org at runtime"
    (interactive)
    (org-babel-load-file (expand-file-name "~/.emacs.d/config.org")))
  (global-set-key (kbd "C-c r") 'config-reload)
#+END_SRC
** which-key
automatic cheat sheet once you press part of a key series
#+BEGIN_SRC emacs-lisp
  (use-package which-key
    :straight t
    :config
    (which-key-mode))
#+END_SRC
* Applications
** youtube-dl
#+BEGIN_SRC emacs-lisp
  (defun play-youtube (url)
    "plays youtube."
    (interactive "sUrl of video: ")
  (shell-command (concat "youtube-dl " url " --add-metadata --write-info-json &" ))
  (emms-add-file (substring (shell-command-to-string (concat "youtube-dl " url " --get-filename ")) 0 -1)))

#+END_SRC
** matrix
#+BEGIN_SRC emacs-lisp
  (use-package ement
    :straight (ement :type git :host github :repo "alphapapa/ement.el")
    :config (ement-connect :user-id "@tay:vexillomancy.org" :uri-prefix "http://localhost:8008" :password (auth-source-pick-first-password
             :host "matrix.vexillomancy.org"
             :user "tay")))
#+END_SRC
** irc
*** circe
*** erc, also known as "a way to ask for help on #emacs"
**** TODO find a way to ignore some channels and only show notifications in modeline
**** Some common settings
This also hides some of the channel messages to avoid cluttering the buffer.
The other line changes the prompt for each channel buffer to match the channel name,
this way you always know who you are typing to.
#+BEGIN_SRC emacs-lisp
  (setq erc-nick "htayj")
  (setq erc-prompt (lambda () (concat "[" (buffer-name) "]")))
  (setq erc-hide-list '("JOIN" "PART" "QUIT"))
  (setq erc-interpret-mirc-color t)
  (setq erc-modules
     '(completion log notifications hl-nicks netsplit fill button match track readonly networks ring autojoin noncommands irccontrols move-to-prompt stamp menu list))
  '(erc-prompt-for-password nil)


  (setq erc-track-exclude-types '("JOIN" "KICK" "NICK" "PART" "333" "353"))
#+END_SRC

**** selectable server list
this changes the =erc= history to include the server I connect to often.
#+BEGIN_SRC emacs-lisp
  (setq erc-server-history-list '("irc.libera.chat"
                                   "irc.deft.com"
                                   "localhost"))
  (setq erc-autojoin-channels-alist '( ("libera.chat" "#pine64" "#fsf" "#searx" "#guix" "#emacs" "#hurd" "#guix" "#lisp" "##trans" "##transgeeks") ))

  (setq erc-autojoin-timing 'ident)

  (setq erc-track-exclude
     '("##latinitas" "##latin" "#EsperantoAmeriko#1" "#kulupupitokipona#1"))
#+END_SRC

**** Nick highlighting
You can even highlight nicks to make the buffers a bit more visually pleasing and easier to look at.
#+BEGIN_SRC emacs-lisp
  (use-package erc-hl-nicks
    :straight t
    :config
    (erc-update-modules))
#+END_SRC
*** ELIM
#+BEGIN_SRC emacs-lisp
  ;; (add-to-list 'load-path "~/elim/elisp")
  ;; (load-library "garak")
#+END_SRC
*** Circe
another irc client
#+BEGIN_SRC emacs-lisp
    (use-package circe
      :straight t)
#+END_SRC
** EMMS 
There is many backends, many players and codecs for EMMS, we use mpd now.

**** Basic setup for mpd
The non XF86 keys are made to be somewhat logical to follow and easy to remember.
At the bottom part of the configuration, you will notice how XF86 keys are used
by default, so unless you keyboard is broken it should work out of the box.
Obviously you might have to adjust /server-name/ and /server-port/ to fit your configuration.
#+BEGIN_SRC emacs-lisp
  (use-package emms
    :straight t
    :config
    (require 'emms-setup)
    ;; (require 'emms-player-mpd)
    (emms-all) ; don't change this to values you see on stackoverflow questions if you expect emms to work
    (setq emms-seek-seconds 5)
    (emms-default-players)
    (setq emms-player-list '(emms-player-mpd))
    (setq emms-info-functions '(emms-info-mpd))
    (setq emms-player-mpd-server-name "localhost")
    (setq emms-player-mpd-server-port "6600")     
    (setq emms-source-file-default-directory "~/Media/")
    :bind
    ;; ("s-m p" . emms)
    ;; ("s-m b" . emms-smart-browse)
    ;; ("s-m r" . emms-player-mpd-update-all-reset-cache)
    ("<XF86AudioPrev>" . emms-previous)
    ("<XF86AudioNext>" . emms-next)
    ("<XF86AudioPlay>" . emms-pause)
    ("<XF86AudioPause>" . emms-pause)
    ("<XF86AudioStop>" . emms-stop))
#+END_SRC

**** MPC Setup
***** Setting the default port
We use non-default settings for the socket, to use the built in =mpc= functionality we need to set up a variable.
Adjust according to your setup.
#+BEGIN_SRC emacs-lisp
  (setq mpc-host "localhost:6601")
#+END_SRC
**** mpv
#+BEGIN_SRC emacs-lisp
  ;;   (use-package emms-player-mpv
  ;; :straight t
  ;; :config
  ;; (add-to-list 'emms-player-list 'emms-player-mpv))
#+END_SRC
**** Some more fun stuff
***** Starting the daemon from within emacs
If you have an absolutely massive music library, it might be a good idea to get rid of =mpc-update=
and only invoke it manually when needed.
#+BEGIN_SRC emacs-lisp
  (defun mpd/start-music-daemon ()
    "Start MPD, connects to it and syncs the metadata cache."
    (interactive)
    (shell-command "mpd")
    (mpd/update-database)
    (emms-player-mpd-connect)
    (emms-cache-set-from-mpd-all)
    (message "MPD Started!"))
  ;;(global-set-key (kbd "s-m c") 'mpd/start-music-daemon)
#+END_SRC

***** Killing the daemon from within emacs
#+BEGIN_SRC emacs-lisp
  (defun mpd/kill-music-daemon ()
    "Stops playback and kill the music daemon."
    (interactive)
    (emms-stop)
    (call-process "killall" nil nil nil "mpd")
    (message "MPD Killed!"))
  ;;(global-set-key (kbd "s-m k") 'mpd/kill-music-daemon)
#+END_SRC
***** Updating the database easily.
#+BEGIN_SRC emacs-lisp
  (defun mpd/update-database ()
    "Updates the MPD database synchronously."
    (interactive)
    (call-process "mpc" nil nil nil "update")
    (message "MPD Database Updated!"))
  ;;(global-set-key (kbd "s-m u") 'mpd/update-database)
#+END_SRC
*** Audio controls
This is a set of bindings to my XF86 keys that invokes pulsemixer with the correct parameters

**** Volume modifier
It goes without saying that you are free to modify the modifier as you see fit, 4 is good enough for me though.
#+BEGIN_SRC emacs-lisp
  (defconst volumeModifier "4")
#+END_SRC

**** Functions to start processes
#+BEGIN_SRC emacs-lisp
  (defun audio/mute ()
    (interactive)
    (start-process "audio-mute" nil "pulsemixer" "--toggle-mute"))

  (defun audio/raise-volume ()
    (interactive)
    (start-process "raise-volume" nil "pulsemixer" "--change-volume" (concat "+" volumeModifier)))

  (defun audio/lower-volume ()
    (interactive)
    (start-process "lower-volume" nil "pulsemixer" "--change-volume" (concat "-" volumeModifier)))
#+END_SRC

**** Keybindings to start processes
You can also change those if you'd like, but I highly recommend keeping 'em the same, chances are, they will just work.
#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "<XF86AudioMute>") 'audio/mute)
  (global-set-key (kbd "<XF86AudioRaiseVolume>") 'audio/raise-volume)
  (global-set-key (kbd "<XF86AudioLowerVolume>") 'audio/lower-volume)
#+END_SRC
** File Manager
*** Dired
#+BEGIN_SRC emacs-lisp
  (setq-default dired-listing-switches "-alh")
  (use-package all-the-icons-dired
    :straight t
    :hook (dired-mode . all-the-icons-dired-mode)
    )
#+END_SRC
** The terminal
*** Default shell
#+BEGIN_SRC emacs-lisp
  (defvar my-term-shell "/bin/bash")
  (defadvice ansi-term (before force-bash)
    (interactive (list my-term-shell)))
  (ad-activate 'ansi-term)
#+END_SRC
** web browser
*** elpher for gopher and gem
#+BEGIN_SRC emacs-lisp
  (use-package elpher
    :straight t)
#+END_SRC
*** w3m
#+BEGIN_SRC emacs-lisp
  (use-package w3m
    :straight t)
#+END_SRC
*** ace-link for eww 
#+BEGIN_SRC emacs-lisp
  (use-package ace-link
    :straight t
    :config
    (ace-link-setup-default)
  )


#+END_SRC
** elfeed
replacing gnus with elfeed
*** COMMENT elfeed itself
#+BEGIN_SRC emacs-lisp
  (use-package elfeed
    :straight t
    :custom
    (elfeed-search-filter "@6-months-ago +unread -vid"))
#+END_SRC
*** COMMENT elfeed goodies
*** COMMENT org mode feed list
#+BEGIN_SRC emacs-lisp
    (use-package elfeed-org
      :straight t
    :config
(elfeed-org)
(setq rmh-elfeed-org-files (list "~/Dropbox/newsfeeds.org" )))
#+END_SRC
** COMMENT gnus
*** COMMENT hackernews in gnus
i may turn this back on once i have a better grasp of gnus

#+BEGIN_SRC emacs-lisp
    (use-package nnhackernews
      :straight t
    :config
(add-to-list 'gnus-secondary-select-methods '(nnhackernews "")))

#+END_SRC
*** reddit in gnus
i may turn this back on once i have a better grasp of gnus
#+BEGIN_SRC emacs-lisp
  ;; (use-package nnreddit
  ;; :straight t
  ;; :config 

  ;; (add-to-list 'gnus-secondary-select-methods '(nnreddit "")))
#+END_SRC
*** convert atom feeds to rss
#+BEGIN_SRC emacs-lisp

  ;; (require 'mm-url)
  ;; (defadvice mm-url-insert (after DE-convert-atom-to-rss () )
  ;;   "Converts atom to RSS by calling xsltproc."
  ;;   (when (re-search-forward "xmlns=\"http://www.w3.org/.*/Atom\"" 
  ;; 			   nil t)
  ;;     (goto-char (point-min))
  ;;     (message "Converting Atom to RSS... ")
  ;;     (call-process-region (point-min) (point-max) 
  ;; 			 "xsltproc" 
  ;; 			 t t nil 
  ;; 			 (expand-file-name "~/atom2rss.xsl") "-")
  ;;     (goto-char (point-min))
  ;;     (message "Converting Atom to RSS... done")))

  ;; (ad-activate 'mm-url-insert)

#+END_SRC

** DONE COMMENT slack
- State "DONE"       from "TODO"       [2023-01-25 Wed 20:18]
#+BEGIN_SRC emacs-lisp
  ;; https://github.com/jackellenberger/emojme#user-content-finding-a-slack-cookie

  (use-package websocket :straight t)
  (use-package request :straight t)
  (use-package oauth2 :straight t)
  (use-package slack
    :straight (slack :type git :host github :repo "seblemaguer/emacs-slack")
    :after evil
    :init
    (setq slack-buffer-emojify t) ;; if you want to enable emoji, default nil
    (setq slack-prefer-current-team t)
    :config
    (slack-register-team
     :name "codemettle"
     :default t
     :token (auth-source-pick-first-password
           :host "codemettle.slack.com"
           :user "slack^token")
     :cookie (auth-source-pick-first-password
           :host "codemettle.slack.com"
           :user "slack^cookie")
     :subscribed-channels '(random)
     :full-and-display-names t)
    (evil-define-key 'normal slack-info-mode-map
      ",u" 'slack-room-update-messages)
    (evil-define-key 'normal slack-mode-map
      ",c" 'slack-buffer-kill
      ",ra" 'slack-message-add-reaction
      ",rr" 'slack-message-remove-reaction
      ",rs" 'slack-message-show-reaction-users
      ",pl" 'slack-room-pins-list
      ;; ",pa" 'slack-message-pins-add
      ;; ",pr" 'slack-message-pins-remove
      ",mm" 'slack-message-write-another-buffer
      ",me" 'slack-message-edit
      ",md" 'slack-message-delete
      ",u" 'slack-room-update-messages
      ",2" 'slack-message-embed-mention
      ",3" 'slack-message-embed-channel
      "\C-n" 'slack-buffer-goto-next-message
      "\C-p" 'slack-buffer-goto-prev-message)
    (evil-define-key 'normal slack-edit-message-mode-map
      ",k" 'slack-message-cancel-edit
      ",s" 'slack-message-send-from-buffer
      ",2" 'slack-message-embed-mention
      ",3" 'slack-message-embed-channel) )


  (use-package helm-slack
    :straight (helm-slack :type git :host github :repo "yuya373/helm-slack") 
    :after (slack)) ;; optional

  (url-cookie-store
   "d"
   ( auth-source-pick-first-password
     :host "codemettle.slack.com"
     :user "slack^cookie" )
   nil ".slack.com" "/" t)
  (url-cookie-store
   "d-s"
   ( auth-source-pick-first-password
     :host "codemettle.slack.com"
     :user "slack^ds" )
   nil ".slack.com" "/" t)
#+END_SRC

** gptel for a real interface to chatgpt

#+BEGIN_SRC emacs-lisp
  (use-package gptel
    :straight t
    :config
    (gptel-make-ollama "Ollama"             ;Any name of your choosing
    :host "d:11434"               ;Where it's running
    :stream t                             ;Stream responses
    :models '("dolphin-phi"))          ;List of models
    )
#+END_SRC


** TODO discord in emacs
** TODO everything in emacs
** TODO email
#+BEGIN_SRC emacs-lisp

  ;; (use-package mu4e
  ;;   :straight t)
  (setq
    rmail-primary-inbox-list '("pop://taylor%40taylorhardy.net@pop.gmail.com")
    rmail-preserve-inbox t
    user-full-name "Taylor Hardy"
    user-mail-address "taylor@taylorhardy.net")
#+END_SRC
** byzanz record
use byzanz to record the screen, with ability to select region
#+BEGIN_SRC emacs-lisp
  (defun emacs-byzanz-record (&optional w h x y)
    (interactive)

      (add-to-list 'display-buffer-alist
      (cons "emacs-record" (cons #'display-buffer-no-window nil)))
    (async-shell-command (format "byzanz-record -e \"bash -c 'exec -a emacs_record sleep infinity'\" %s" (concat (getenv "HOME") "/" (subseq (number-to-string (float-time)) 0 10) ".gif")) "emacs-record")
   )

  (defun emacs-byzanz-record-stop ()
    (interactive)
    (shell-command "pkill -xef 'emacs_record infinity'")
    )
  (defun byzanz-record-region ()
    (interactive)
    (when window-system
        (call-process "import" nil nil nil ".newScreen.png")
        (let ((width (shell-command-to-string "identify -format '%w' .newScreen.png"))
              (height (shell-command-to-string "identify -format '%h' .newScreen.png"))
              (xoff (shell-command-to-string "identify -format '%X' .newScreen.png"))
              (yoff (shell-command-to-string "identify -format '%Y' .newScreen.png")))
          (message (format "capturing on: w:%s h:%s X:%s Y:%s" width height xoff yoff))
          (message (format "byzanz-record -w %s -h %s -x %s -y %s -e \"bash -c 'exec -a emacs_record sleep infinity'\" %s" width height xoff yoff (concat (getenv "HOME") "/" (subseq (number-to-string (float-time)) 0 10) ".gif")) )
          (add-to-list 'display-buffer-alist
                       (cons "emacs-record" (cons #'display-buffer-no-window nil)))
          (async-shell-command (format "byzanz-record -w %s -h %s -x %s -y %s -e \"bash -c 'exec -a emacs_record sleep infinity'\" %s" width height xoff yoff (concat (getenv "HOME") "/" (subseq (number-to-string (float-time)) 0 10) ".gif")) "emacs-record" )
          )
        (call-process "rm" nil nil nil ".newScreen.png")
        (message "byzanz capture started")) )
#+END_SRC

** COMMENT eaf
gui applications from inside emacs using python repl connected to the lisp
#+BEGIN_SRC emacs-lisp
  (use-package eaf
    :load-path "~/.emacs.d/site-lisp/emacs-application-framework" ; Set to "/usr/share/emacs/site-lisp/eaf" if installed from AUR
    :custom
    (eaf-find-alternate-file-in-dired t)
    :config
    (define-key dired-mode-map (kbd "e") 'eaf-open-this-from-dired)
    (require 'eaf-camera)
    (require 'eaf-music-player)
    (require 'eaf-org-previewer)
    (require 'eaf-pdf-viewer)
    (require 'eaf-jupyter)
    (require 'eaf-video-player)
    (require 'eaf-browser)
    (require 'eaf-markdown-previewer)
    (require 'eaf-image-viewer)
    (require 'eaf-mindmap)
    (require 'eaf-system-monitor))
#+END_SRC


** Default browser
I use eww for most browsing, and I use qutebrowser when I need to open something in an external browser.
#+BEGIN_SRC emacs-lisp
  (setq browse-url-browser-function 'eww-browse-url
        browse-url-generic-program "qutebrowser")

  (setq eww-search-prefix "http://www.duckduckgo.com/lite?q=")
  ;; (setq eww-search-prefix "http://localhost/?preferences=eJx9VsFu5DYM_Zr6YiTodg89zaFoUewCBbJosr0atER7uJZErSSPo3x9qRmPR55se8ggpqnHR_KRsoKEIwfCeBjRYQDTGHDjDCMe0D18fW4MKzDloYE5sWLrDSY8nJ8GVnM8vIQZGwjqSCfsEmvIhz_BRGzICkznA79eLRbTkfXhy9PzSxNhwIjl3OHnJh3R4iFSQW8Cxtmk2LHrHC5dgn49rpk6ecnmhOHAII-PHMaGo4LwEFMWnoZHUqzx1IA-gVOouzXICkEReiNWdCM5SZus7rtuTf6nX35faCJLjva2PtfPGHghXVscCKXaUDj0GMauo1QQOGhHU-0BbyYHUrG2RbTgEqk2qiMbEMSoCCULeWezRcshtymAi0Yat2Mweta6cBjIYBTDRGqCKPB2jqQKOBvSiUNAJ8Xd_AJqTUl4lm7FM4k3B7bGDnOfR7RxTebDa-XtMsAtBrkTaeJZXOUf5OKxHEVAUWLjji_zaLD1BnIL3leE9KzR1a4V6DVOhiPzD9OPrAhMa1ETlGQShOSLDivnQQcu_btGtPwNcbpTQSJ2EHZ9_75Id9pL6lUJtkpvKWsevWDvCEqERBavRSw6-z5z2jklkWTGCnoOPThN6gdkZhelePFYedc1tXwirDmlk4W3XTSfPa1sEk-ZE8cjT-BuZS4kT5zvyrfOeks77Q4BLBjqA66YeRxXtVX68ENsLwN5M4KfWkshcKXekUaZU4hpJ4T6dDWOKVt2Rmq3YxmnvYZtXzqy1eOq-zoDxDbykBYI2GoKqCSBvKajZzWVv1F0t2Bf6ocJzJ4Is7kb6EK2LIO2_KxQ19Cy3QoTpdRDOlXUNjFXytg36OZKyUC_4g6B3ESgam3CPMhG362KDx8__vpaYfRBtlftcAQxlZ8V9zLjG-ZlDC7HK5htDK49XPiVJnaPknzMjp0ssF1H1ircTWwtmw1JdKghQX3ccB8TPoZ6oCLPQe2C9JR6aRqmd118P8ceMaS5r0VSk7lNtx5bjYNcEmUsd_2uRVLpogdRkfTOe3JjKai3K5-dpDcmd92-lqGX07sSyLTJVmiLJe6nsVSjZ57eGeWeipTyvblIcRMkOajSjd_8o1_cfw7i5sgeXUDPlQQuyrl4NOj2Vy87fD_MlxPX82ep_W_KZ8_bte7NLODx8IljklsM5XtB1uH5Av3szi1DuVMDmwL2JIS735RCUe0fT5_FdwniIG_-IftgaMLuyGnCfOO-4ZfNe3kQ95cAorHQff37LwGR1YtBrM9ohk6icrBwVsrZdk5YShVAlFVMn15evjxXsa8urlOXr7MsnzBGdlEjskCJ_S8t36lz&q=" )
#+END_SRC


shrface for eww that is more like org mode
#+BEGIN_SRC emacs-lisp
  ;; (use-package shrface
  ;;   :defer t
  ;;   :straight t
  ;;   :config
  ;;   (shrface-basic)
  ;;   (shrface-trial)
  ;;   (setq shrface-href-versatile t))

  ;; (use-package eww
  ;;   :init
  ;;   (add-hook 'eww-after-render-hook #'shrface-mode)
  ;;   :config
  ;;   (require 'shrface))

#+END_SRC


sometimes i load a page and it has a lot of animated images and it makes eww crawl, or it has big images that make the page hard to read, so I dont open images by default, but this neat script i found lets you turn on and off images.
#+BEGIN_SRC emacs-lisp
  (defun my/eww-toggle-images ()
    "Toggle whether images are loaded and reload the current page from cache."
    (interactive)
    (setq-local shr-inhibit-images (not shr-inhibit-images))
    (eww-reload t)
    (message "Images are now %s"
             (if shr-inhibit-images "off" "on")))

  ;; (define-key eww-mode-map (kbd "I") #'my/eww-toggle-images)
  ;; (define-key eww-link-keymap (kbd "I") #'my/eww-toggle-images)

  ;; minimal rendering by default
  (setq-default shr-inhibit-images t)   ; toggle with `I`
  (setq-default shr-use-fonts nil)      ; toggle with `F`
#+END_SRC

this highlights syntax in eww, good for elisp snippets on the wiki.
#+BEGIN_SRC emacs-lisp
  ;; syntax highlighting 
  (use-package language-detection
    :straight t
    :config
    (require 'cl-lib)

    (defun eww-tag-pre (dom)
      (let ((shr-folding-mode 'none)
            (shr-current-font 'default))
        (shr-ensure-newline)
        (insert (eww-fontify-pre dom))
        (shr-ensure-newline)))

    (defun eww-fontify-pre (dom)
      (with-temp-buffer
        (shr-generic dom)
        (let ((mode (eww-buffer-auto-detect-mode)))
          (when mode
            (eww-fontify-buffer mode)))
        (buffer-string)))

    (defun eww-fontify-buffer (mode)
      (delay-mode-hooks (funcall mode))
      (font-lock-default-function mode)
      (font-lock-default-fontify-region (point-min)
                                        (point-max)
                                        nil))

    (defun eww-buffer-auto-detect-mode ()
      (let* ((map '((ada ada-mode)
                    (awk awk-mode)
                    (c c-mode)
                    (cpp c++-mode)
                    (clojure clojure-mode lisp-mode)
                    (csharp csharp-mode java-mode)
                    (css css-mode)
                    (dart dart-mode)
                    (delphi delphi-mode)
                    (emacslisp emacs-lisp-mode)
                    (erlang erlang-mode)
                    (fortran fortran-mode)
                    (fsharp fsharp-mode)
                    (go go-mode)
                    (groovy groovy-mode)
                    (haskell haskell-mode)
                    (html html-mode)
                    (java java-mode)
                    (javascript javascript-mode)
                    (json json-mode javascript-mode)
                    (latex latex-mode)
                    (lisp lisp-mode)
                    (lua lua-mode)
                    (matlab matlab-mode octave-mode)
                    (objc objc-mode c-mode)
                    (perl perl-mode)
                    (php php-mode)
                    (prolog prolog-mode)
                    (python python-mode)
                    (r r-mode)
                    (ruby ruby-mode)
                    (rust rust-mode)
                    (scala scala-mode)
                    (shell shell-script-mode)
                    (smalltalk smalltalk-mode)
                    (sql sql-mode)
                    (swift swift-mode)
                    (visualbasic visual-basic-mode)
                    (xml sgml-mode)))
             (language (language-detection-string
                        (buffer-substring-no-properties (point-min) (point-max))))
             (modes (cdr (assoc language map)))
             (mode (cl-loop for mode in modes
                            when (fboundp mode)
                            return mode)))
        (message (format "%s" language))
        (when (fboundp mode)
          mode)))

    (setq shr-external-rendering-functions
          '((pre . eww-tag-pre))))

#+END_SRC

** shr settings
#+BEGIN_SRC emacs-lisp
  (setq shr-indentation 2
        shr-width 90)
#+END_SRC

** Screenshots
I don't need scrot to take screenshots, or shutter or whatever tools you might have. This is enough.
These won't work in the terminal version or the virtual console, obvious reasons.

*** Screenshotting the entire screen
#+BEGIN_SRC emacs-lisp
  (defun daedreth/take-screenshot ()
    "Takes a fullscreen screenshot of the current workspace"
    (interactive)
    (when window-system
      (loop for i downfrom 3 to 1 do
            (progn
              (message (concat (number-to-string i) "..."))
              (sit-for 1)))
      (message "Cheese!")
      (sit-for 1)
      (start-process "screenshot" nil "import" "-window" "root" 
                     (concat (getenv "HOME") "/" (subseq (number-to-string (float-time)) 0 10) ".png"))
      (message "Screenshot taken!")))
  (global-set-key (kbd "<print>") 'daedreth/take-screenshot)
#+END_SRC

*** Screenshotting a region
#+BEGIN_SRC emacs-lisp
  (defun daedreth/take-screenshot-region ()
    "Takes a screenshot of a region selected by the user."
    (interactive)
    (when window-system
      (call-process "import" nil nil nil ".newScreen.png")
      (call-process "convert" nil nil nil ".newScreen.png" "-shave" "1x1"
                    (concat (getenv "HOME") "/" (subseq (number-to-string (float-time)) 0 10) ".png"))
      (call-process "rm" nil nil nil ".newScreen.png")))
  (global-set-key (kbd "S-<print>") 'daedreth/take-screenshot-region)
  (global-set-key (kbd "C-c o") 'daedreth/take-screenshot-region)
#+END_SRC
** vterm
sometimes need better than ansi-term

#+BEGIN_SRC emacs-lisp
  (use-package vterm
    :straight t)

#+END_SRC
** Git integration
*** magit
#+BEGIN_SRC emacs-lisp
  (use-package magit
    :straight t
    :config
    (setq magit-push-always-verify nil)
    (setq git-commit-summary-max-length 80)
    :bind
    ("C-c g" . sudo-edit))
#+END_SRC
*** git gutter
#+BEGIN_SRC emacs-lisp
  (use-package diff-hl
    :straight t
    :config
    (global-diff-hl-mode))
#+END_SRC
*** magit forge
#+BEGIN_SRC emacs-lisp
  (use-package forge
    :straight t
    :after magit)

  (use-package code-review
    :straight '(code-review :type git :host github :repo "phelrine/code-review" :branch "fix/closql-update")
    :config
    (setq code-review-auth-login-marker 'forge))
  ;; (straight-use-package '(tsx-mode :type git :host github :repo "phelrine/code-review" :branch "fix/closql-update"))
#+END_SRC
** COMMENT ansi term enhancement
#+BEGIN_SRC emacs-lisp
  (defun singpolyma/term-insert-literal (key)
      "Take a keypress and insert it literally into a terminal."
      (interactive "cPress key:")
      (term-send-raw-string (format "%c" key))
      )

  (add-hook 'term-mode-hook (lambda ()
          (define-key evil-insert-state-map (kbd "C-'") 'singpolyma/term-insert-literal)
          )
#+END_SRC
** COMMENT chatgpt openai
#+BEGIN_SRC emacs-lisp
  ;; https://github.com/jackellenberger/emojme#user-content-finding-a-slack-cookie
  (require 'openai)
  ;; (el-get-bundle emacs-openai/openai) ;; optional
  ;; (use-package openai
  ;;   :straight t)
#+END_SRC

* Appearance
** Theme
*** high contrast

#+BEGIN_SRC emacs-lisp

  (use-package modus-themes
    :straight t 
    :init 
    (setq modus-vivendi-theme-slanted-constructs t
          modus-vivendi-theme-bold-constructs t
          modus-vivendi-theme-visible-fringes t
          modus-vivendi-theme-3d-modeline t
          modus-vivendi-theme-subtle-diffs t
          modus-vivendi-theme-intense-standard-completions t
          modus-vivendi-theme-distinct-org-blocks t
          modus-vivendi-theme-rainbow-org-src-blocks t
          modus-vivendi-theme-proportional-fonts t
          modus-vivendi-theme-rainbow-headings t
          modus-vivendi-theme-section-headings t)
    :config
    (load-theme 'modus-vivendi t))
#+END_SRC

*** Font
#+BEGIN_SRC emacs-lisp
  ;; Set default font
  (set-face-attribute 'default nil
                      :foundry "UW" :family "Ttyp0"
                      :height 110
                      :weight 'bold)
  ;; set fallback font for emoji
  (set-fontset-font t nil (font-spec :size 20 :name "Unifont"))

  ;;; use this font 
  ;; ftcrhb:-V.R.-Bm437 IBM VGA 9x16-regular-normal-normal-*-16-*-*-*-m-*-iso10646-1 (#x0C)
#+END_SRC
*** ansi color names
#+BEGIN_SRC emacs-lisp
(setq ansi-color-names-vector
   ["#303030" "#f2241f" "#67b11d" "#b1951d" "#4f97d7" "#a31db1" "#28def0" "#b2b2b2"])
#+END_SRC
** emojis
add emoji rendering
#+BEGIN_SRC emacs-lisp
    (use-package emojify
      :straight t)
#+END_SRC
** UI modernization
*** Icons to make things pretty
M-x all-the-icons-install-fonts
#+BEGIN_SRC emacs-lisp
  (use-package all-the-icons
    :straight t)
#+END_SRC
* Text Editor
** evil
#+BEGIN_SRC emacs-lisp
  (use-package evil
    :straight t
    :init
    (setq evil-want-integration t)
    (setq evil-want-keybinding nil)
    :custom
    (evil-undo-system 'undo-tree)
    (evil-search-module 'isearch)
    :config
    (evil-mode 1)
    (setq evil-search-module 'isearch)
    (define-key evil-insert-state-map (kbd "C-g") 'evil-normal-state))

  (use-package evil-collection
    :after evil
    :straight t
    :config
    (evil-collection-init)
    (setq evil-want-keybinding t)
    (evil-set-initial-state 'eaf-mode 'emacs)
    (evil-set-initial-state 'exwm-mode 'emacs))
  (use-package evil-surround
    :straight t
    :config
    (global-evil-surround-mode 1))
#+END_SRC

** undo tree
#+BEGIN_SRC emacs-lisp
  (use-package undo-tree
    :straight t
    :config
    (setq undo-tree-history-directory-alist '(("." . "~/.emacs.d/undo")))
    (global-undo-tree-mode))
#+END_SRC
** evil key mods
M - can be replaced with major mode leaders - middle line
H - can be replaced with backwards - first line
L - can be replaced with forwards - last line
K - replace with read man command
{,} - can be replaced with back/forward paragraph

s - can be replaced - rarely used, shortcut for `cl`
R - can be replaced - never used, trouble with `C-g`
Z - can be replaced - duplicated with emacs keys
X - can be replaced - never used, odd behavior

U - undefined

yy is the same as Y? shouldnt Y be rest of line?


** Basic Interface Settings
These are setting that do not depend on packages and are built-in enhancements to the UI.

*** Looks
**** remove original dashboard
#+BEGIN_SRC emacs-lisp
  (setq inhibit-startup-message t)
#+END_SRC
**** Disable menus and scrollbars
If you like using any of those, change =-1= to =1=.
#+BEGIN_SRC emacs-lisp
  (tool-bar-mode -1)
  (menu-bar-mode -1)
  (scroll-bar-mode -1)
#+END_SRC

**** Set UTF-8 encoding
#+BEGIN_SRC emacs-lisp 
  (setq locale-coding-system 'utf-8)
  (set-terminal-coding-system 'utf-8)
  (set-keyboard-coding-system 'utf-8)
  (set-selection-coding-system 'utf-8)
  (prefer-coding-system 'utf-8)
#+END_SRC
**** COMMENT Highlight current line
=hl-line= is awesome! It's not very awesome in the terminal version of emacs though, so we don't use that.
Besides, it's only used for programming.
#+BEGIN_SRC emacs-lisp
  (when window-system (add-hook 'prog-mode-hook 'hl-line-mode))
#+END_SRC

**** visual bell
#+BEGIN_SRC emacs-lisp
  (setq visible-bell t)
#+END_SRC


*** Functionality
**** backups and auto-saves
I don't use either, you might want to turn those from =nil= to =t= if you do.
#+BEGIN_SRC emacs-lisp
  (setq make-backup-files nil)
  (setq auto-save-default nil)
#+END_SRC

**** Change yes-or-no questions into y-or-n questions
#+BEGIN_SRC emacs-lisp
  (defalias 'yes-or-no-p 'y-or-n-p)
#+END_SRC

**** Async
use asynchronous processes wherever possible
#+BEGIN_SRC emacs-lisp
  (use-package async
    :straight t
    :init (dired-async-mode 1))
#+END_SRC

** Projectile

*** Enable projectile globally
This makes sure that everything can be a project.

#+BEGIN_SRC emacs-lisp
  (use-package projectile
    :straight t
    :init (projectile-mode 1)
    :custom 
    (projectile-indexing-method 'hybrid)
    ;; :custom
    ;; (projectile-completion-system)
    :bind ("C-c p" . 'projectile-command-map))

  (use-package helm-projectile
    :straight t
    :config (helm-projectile-on))
  (use-package helm-rg
    :straight t)
  ;; (use-package counsel-projectile
  ;;   :straight t
  ;;   :config (counsel-projectile-mode))
  ;; (setq projectile-project-search-path '("~/ttui/" "~/terminus/" ))
#+END_SRC

*** Let projectile call make
#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "<f5>") 'projectile-compile-project)
#+END_SRC

** Programming
*** lsp
#+BEGIN_SRC emacs-lisp
  ;;EGLOT
  (use-package eglot)

  (add-to-list 'eglot-server-programs
               '((tsx-mode) "typescript-language-server" "--stdio"))
  (add-to-list 'eglot-server-programs
               '((tsx-ts-mode) "typescript-language-server" "--stdio"))
  (add-to-list 'eglot-server-programs
               '((js-json-mode) "vscode-json-languageserver" "--stdio"))


  ;;LSPMODE
  ;; (use-package lsp-mode
  ;;   ;; Optional - enable lsp-mode automatically in scala files
  ;;   :straight t
  ;;   :hook  (scala-mode . lsp)
  ;;          (lsp-mode . lsp-lens-mode)
  ;;   :config (setq lsp-prefer-flymake nil))

  ;; (use-package lsp-mode
  ;;   :custom
  ;;   (lsp-completion-provider :none) ;; we use Corfu!
  ;;   :init
  ;;   ;; set prefix for lsp-command-keymap (few alternatives - "C-l", "C-c l")
  ;;   (setq lsp-keymap-prefix "C-c l")
  ;;   (defun my/orderless-dispatch-flex-first (_pattern index _total)
  ;;     (and (eq index 0) 'orderless-flex))

  ;;   (defun my/lsp-mode-setup-completion ()
  ;;     (setf (alist-get 'styles (alist-get 'lsp-capf completion-category-defaults))
  ;;           '(orderless))
  ;;     ;; Optionally configure the first word as flex filtered.
  ;;     (add-hook 'orderless-style-dispatchers #'my/orderless-dispatch-flex-first nil 'local)
  ;;     ;; Optionally configure the cape-capf-buster.
  ;;     (setq-local completion-at-point-functions (list (cape-capf-buster #'lsp-completion-at-point))))
  ;;   :straight t
  ;;   :after evil
  ;;   :vbind (( :map ( lsp-mode-map . normal )
  ;;               ("gr" . lsp-find-references)
  ;;               ("glo" . lsp-organize-imports)
  ;;               ("gt" . lsp-find-type-definition) ))
  ;;   :hook (;; replace XXX-mode with concrete major-mode(e. g. python-mode)
  ;;          (lsp-completion-mode . my/lsp-mode-setup-completion)
  ;;          (scala-mode . lsp)
  ;;          (tsx-mode . lsp)
  ;;          (tsx-ts-mode . lsp)
  ;;          (typescript-ts-mode . lsp)
  ;;          ;; lens mode
  ;;          (lsp-mode . lsp-lens-mode)
  ;;          ;; if you want which-key integration
  ;;          (lsp-mode . lsp-enable-which-key-integration))
  ;;   :commands lsp)

  ;;    ;; optionally
  ;; (use-package lsp-ui :straight t :commands lsp-ui-mode)
  ;;    ;; if you are helm user
  ;; (use-package helm-lsp :straight t :commands helm-lsp-workspace-symbol)
  ;;    ;; if you are ivy user
  ;; (use-package lsp-treemacs :commands lsp-treemacs-errors-list)

  ;;    ;; optionally if you want to use debugger
  ;; (use-package dap-mode)
#+END_SRC
*** COMMENT treesitter TODO: disable when upgrade to 29
#+BEGIN_SRC emacs-lisp

  (use-package tree-sitter
    :straight t )

  (use-package tree-sitter-langs
    :straight t
    :config
    (tree-sitter-require 'tsx)
    (add-to-list 'tree-sitter-major-mode-language-alist '(tsx-mode . tsx))
    (add-to-list 'tree-sitter-major-mode-language-alist '(tsx-ts-mode . tsx)))

  (use-package evil-textobj-tree-sitter :straight t)
#+END_SRC
*** built in tree sit

#+BEGIN_SRC emacs-lisp

  (require 'treesit)
#+END_SRC
*** COMMENT paredit
#+BEGIN_SRC emacs-lisp
  (use-package paredit
    :straight t
    :config
    (autoload 'enable-paredit-mode "paredit" "Turn on pseudo-structural editing of Lisp code." t)
    (add-hook 'emacs-lisp-mode-hook       #'enable-paredit-mode)
    (add-hook 'eval-expression-minibuffer-setup-hook #'enable-paredit-mode)
    (add-hook 'ielm-mode-hook             #'enable-paredit-mode)
    (add-hook 'lisp-mode-hook             #'enable-paredit-mode)
    (add-hook 'lisp-interaction-mode-hook #'enable-paredit-mode)
    (add-hook 'scheme-mode-hook           #'enable-paredit-mode))
#+END_SRC

*** TODO COMMENT yasnippet
#+BEGIN_SRC emacs-lisp
  (use-package yasnippet
    :straight t
    :config
    (use-package yasnippet-snippets
      :straight t)
    (yas-reload-all))
#+END_SRC

*** flycheck
#+BEGIN_SRC emacs-lisp

  (use-package flycheck
    :straight t
    :config
    (add-hook 'after-init-hook #'global-flycheck-mode)
    :preface

    (defun mp-flycheck-eldoc (callback &rest _ignored)
      "Print flycheck messages at point by calling CALLBACK."
      (when-let ((flycheck-errors (and flycheck-mode (flycheck-overlay-errors-at (point)))))
        (mapc
         (lambda (err)
           (funcall callback
             (format "%s: %s"
                     (let ((level (flycheck-error-level err)))
                       (pcase level
                         ('info (propertize "I" 'face 'flycheck-error-list-info))
                         ('error (propertize "E" 'face 'flycheck-error-list-error))
                         ('warning (propertize "W" 'face 'flycheck-error-list-warning))
                         (_ level)))
                     (flycheck-error-message err))
             :thing (or (flycheck-error-id err)
                        (flycheck-error-group err))
             :face 'font-lock-doc-face))
         flycheck-errors)))

    (defun mp-flycheck-prefer-eldoc ()
      (add-hook 'eldoc-documentation-functions #'mp-flycheck-eldoc nil t)
      (setq eldoc-documentation-strategy 'eldoc-documentation-compose-eagerly)
      (setq flycheck-display-errors-function nil)
      (setq flycheck-help-echo-function nil))

    :hook ((flycheck-mode . mp-flycheck-prefer-eldoc)))
#+END_SRC

*** eldoc-box 
shows box with documentation instead of minibuffer
#+BEGIN_SRC emacs-lisp
  (use-package eldoc-box
    :straight t
    :config
    (add-hook 'eglot-managed-mode-hook #'eldoc-box-hover-at-point-mode t)
    (add-hook 'lsp-managed-mode-hook #'eldoc-box-hover-at-point-mode t)
    (add-hook 'emacs-lisp-mode-hook #'eldoc-box-hover-at-point-mode t))


#+END_SRC
*** corfu mode
#+BEGIN_SRC emacs-lisp
  (use-package corfu
    :straight t
    :custom
    (corfu-auto t)
    :config
    (global-corfu-mode))


  (use-package cape
    :straight t )

#+END_SRC
*** company mode

I prefer =C-n= and =C-p= to move around the items, so I remap those accordingly.
#+BEGIN_SRC emacs-lisp
  (use-package company
    :straight t

    :bind (:map company-active-map
                ("<tab>" . company-complete-selection))
    :config
    (setq company-idle-delay 0)
    (setq company-minimum-prefix-length 1))


#+END_SRC
*** specific languages
Be it for code or prose, completion is a must.
After messing around with =auto-completion= for a while I decided to drop it
in favor of =company=, and it turns out to have been a great decision.

Each category also has additional settings.

**** c/c++
***** COMMENT yasnippet
#+BEGIN_SRC emacs-lisp
  (add-hook 'c++-mode-hook 'yas-minor-mode)
  (add-hook 'c-mode-hook 'yas-minor-mode)
#+END_SRC

***** COMMENT flycheck
#+BEGIN_SRC emacs-lisp
  ;; (use-package flycheck-clang-analyzer
  ;;   :straight t
  ;;   :config
  ;;   (with-eval-after-load 'flycheck
  ;;     (require 'flycheck-clang-analyzer)
  ;;     (flycheck-clang-analyzer-setup)))


#+END_SRC

***** company
Requires libclang to be installed.
#+BEGIN_SRC emacs-lisp
  (with-eval-after-load 'company
    (add-hook 'c++-mode-hook 'company-mode)
    (add-hook 'c-mode-hook 'company-mode))

  (use-package company-c-headers
    :straight t)

  (use-package company-irony
    :straight t
    :config
    (setq company-backends '((company-c-headers
                              company-dabbrev-code
                              company-irony))))

  (use-package irony
    :straight t
    :config
    (add-hook 'c++-mode-hook 'irony-mode)
    (add-hook 'c-mode-hook 'irony-mode)
    (add-hook 'irony-mode-hook 'irony-cdb-autosetup-compile-options))
#+END_SRC

**** python
***** COMMENT yasnippet
#+BEGIN_SRC emacs-lisp
  (add-hook 'python-mode-hook 'yas-minor-mode)
#+END_SRC

***** flycheck
#+BEGIN_SRC emacs-lisp
  (add-hook 'python-mode-hook 'flycheck-mode)
#+END_SRC

***** company
#+BEGIN_SRC emacs-lisp
  (with-eval-after-load 'company
    (add-hook 'python-mode-hook 'company-mode))

  (use-package company-jedi
    :straight t
    :config
    (require 'company)
    (add-to-list 'company-backends 'company-jedi))

  (defun python-mode-company-init ()
    (setq-local company-backends '((company-jedi
                                    company-etags
                                    company-dabbrev-code))))

  (use-package company-jedi
    :straight t
    :config
    (require 'company)
    (add-hook 'python-mode-hook 'python-mode-company-init))
#+END_SRC

**** emacs-lisp
***** eldoc
#+BEGIN_SRC emacs-lisp
  (add-hook 'emacs-lisp-mode-hook 'eldoc-mode)
#+END_SRC

***** COMMENT yasnippet
#+BEGIN_SRC emacs-lisp
  (add-hook 'emacs-lisp-mode-hook 'yas-minor-mode)
#+END_SRC

***** company
#+BEGIN_SRC emacs-lisp
  (add-hook 'emacs-lisp-mode-hook 'company-mode)

  (use-package slime
    :straight t
    :config
    (setq inferior-lisp-program "/usr/bin/sbcl")
    (setq slime-contribs '(slime-fancy)))

  (use-package slime-company
    :straight t
    :init
    (require 'company)
    (slime-setup '(slime-fancy slime-company)))
#+END_SRC

**** lua
***** COMMENT yasnippet
#+BEGIN_SRC emacs-lisp
  (add-hook 'lua-mode-hook 'yas-minor-mode)
#+END_SRC

***** flycheck
#+BEGIN_SRC emacs-lisp
  (add-hook 'lua-mode-hook 'flycheck-mode)
#+END_SRC

***** company
#+BEGIN_SRC emacs-lisp
  (add-hook 'lua-mode-hook 'company-mode)

  (defun custom-lua-repl-bindings ()
    (local-set-key (kbd "C-c C-s") 'lua-show-process-buffer)
    (local-set-key (kbd "C-c C-h") 'lua-hide-process-buffer))

  (defun lua-mode-company-init ()
    (setq-local company-backends '((company-lua
                                    company-etags
                                    company-dabbrev-code))))

  (use-package company-lua
    :straight t
    :config
    (require 'company)
    (setq lua-indent-level 4)
    (setq lua-indent-string-contents t)
    (add-hook 'lua-mode-hook 'custom-lua-repl-bindings)
    (add-hook 'lua-mode-hook 'lua-mode-company-init))
#+END_SRC

**** bash
***** COMMENT yasnippet
#+BEGIN_SRC emacs-lisp
  (add-hook 'shell-mode-hook 'yas-minor-mode)
#+END_SRC

***** flycheck
#+BEGIN_SRC emacs-lisp
  (add-hook 'shell-mode-hook 'flycheck-mode)

#+END_SRC

***** company
#+BEGIN_SRC emacs-lisp
  (add-hook 'shell-mode-hook 'company-mode)

  (defun shell-mode-company-init ()
    (setq-local company-backends '((company-shell
                                    company-shell-env
                                    company-etags
                                    company-dabbrev-code))))

  (use-package company-shell
    :straight t
    :config
    (require 'company)
    (add-hook 'shell-mode-hook 'shell-mode-company-init))
#+END_SRC
**** haskell
#+BEGIN_SRC emacs-lisp
  (use-package haskell-mode
    :straight t)
#+END_SRC
**** COMMENT JS
#+BEGIN_SRC emacs-lisp
  (add-hook 'emacs-lisp-mode-hook 'company-mode)
  ;; (add-hook 'emacs-lisp-mode-hook 'yas-minor-mode)
  (use-package js2-mode
    :straight t
    :init
    (setq js-basic-indent 2)
    (setq js2-strict-missing-semi-warning nil)
    (setq js2-missing-semi-one-line-override t)
    (setq-default js2-basic-indent 2
                  js2-basic-offset 2
                  js2-auto-indent-p t
                  js2-cleanup-whitespace t
                  js2-enter-indents-newline t
                  js2-indent-on-enter-key t
                  js2-global-externs (list "window" "module" "require" "buster" "sinon" "assert" "refute" "setTimeout" "clearTimeout" "setInterval" "clearInterval" "location" "__dirname" "console" "JSON" "jQuery" "$"))

    (add-hook 'js2-mode-hook
              (lambda ()
                (push '("function" . ?ƒ) prettify-symbols-alist)))
    (add-hook 'js2-mode-hook 'company-mode)
    ;; (add-hook 'js2-mode-hook 'yas-minor-mode)
    (add-to-list 'auto-mode-alist '("\\.js$" . js2-mode)))

  ;; jump to definition
  ;;(use-package tern
  ;;   :straight t
  ;;   :init (add-hook 'js2-mode-hook (lambda () (tern-mode t)))
  ;;   :config
  ;;     (use-package company-tern
  ;;        :straight t
  ;;        :init (add-to-list 'company-backends 'company-tern)))
  ;; refactoring (C-c)
  (use-package js2-refactor
    :straight t
    :init   (add-hook 'js2-mode-hook 'js2-refactor-mode)
    :config (js2r-add-keybindings-with-prefix "C-c ."))

  (use-package apheleia
    :straight t
    :config
    (apheleia-global-mode +1)
    (setf (alist-get 'tsx-mode apheleia-mode-alist)
          '(prettier-typescript))
    (setf (alist-get 'tsx-ts-mode apheleia-mode-alist)
          '(prettier-typescript)))

#+END_SRC

**** drools
#+BEGIN_SRC emacs-lisp
  (autoload 'drools-mode "drools-mode")

  (defun set-extension-mode (extension mode)
    (setq auto-mode-alist
          (cons (cons (concat "\\" extension "\\'") mode)
                auto-mode-alist) ) )

  (set-extension-mode ".drl" 'drools-mode)
  (set-extension-mode ".dslr" 'drools-mode)

  (add-hook 'drools-mode-hook 'my-drools-hook)

  (defun drools-return-and-indent()
    (interactive)
    (newline) (indent-for-tab-command) )

  (defun my-drools-hook ()
    (setq indent-tabs-mode nil)
    (local-set-key [?\C-m] 'drools-return-and-indent) )
#+END_SRC

**** scala
#+BEGIN_SRC emacs-lisp
  (use-package scala-mode
    :straight t
    :interpreter
    ("scala" . scala-mode))

  (use-package sbt-mode
    :commands sbt-start sbt-command
    :straight t
    :config
    ;; WORKAROUND: https://github.com/ensime/emacs-sbt-mode/issues/31
    ;; allows using SPACE when in the minibuffer
    (substitute-key-definition
     'minibuffer-complete-word
     'self-insert-command
     minibuffer-local-completion-map)
     ;; sbt-supershell kills sbt-mode:  https://github.com/hvesalai/emacs-sbt-mode/issues/152
     (setq sbt:program-options '("-Dsbt.supershell=false"))
  )


  ;; Add metals backend for lsp-mode
  ;; (use-package lsp-metals
  ;;   :straight t
  ;;   :config (setq lsp-metals-treeview-show-when-views-received nil))

  ;; ;; Enable nice rendering of documentation on hover
  ;; (use-package lsp-ui
  ;;   :straight t)

  ;; Add company-lsp backend for metals
  ;; (use-package company-lsp
  ;;   :straight t)

  ;; Use the Debug Adapter Protocol for running tests and debugging
  (use-package posframe
    :straight t
    ;; Posframe is a pop-up tool that must be manually installed for dap-mode
    )
  ;; (use-package dap-mode
  ;;   :straight t
  ;;   :hook
  ;;   (lsp-mode . dap-mode)
  ;;   (lsp-mode . dap-ui-mode))
#+END_SRC

**** TS
#+BEGIN_SRC emacs-lisp

  (use-package coverlay
    :straight t)

  (use-package origami
    :straight t)
  (use-package css-in-js-mode
    :straight (css-in-js-mode :type git :host github :repo "orzechowskid/tree-sitter-css-in-js"))
    ;; (require 'css-in-js)

  (use-package markdown-mode) ;; required for eglot eldoc
  (use-package tsx-mode
    :straight (tsx-mode :type git :host github :repo "orzechowskid/tsx-mode.el" :branch "emacs29")
    ;; :after eglot
    :config 
    (add-to-list 'auto-mode-alist '("\\.tsx?\\'" . tsx-mode))
    (add-to-list 'auto-mode-alist '("\\.ts?\\'" . tsx-mode)))

  ;; (define-derived-mode typescript-tsx-mode typescript-mode "TSX"
  ;;   "Major mode for editing TSX files.

  ;;   ;; Refer to Typescript documentation for syntactic differences between normal and TSX
  ;;   ;; variants of Typescript.")

  (use-package flymake-eslint
    :straight t
    :config
    (add-hook 'typescript-tsx-mode 
              (lambda ()
                (flymake-eslint-enable)))
    )
    ;; (add-to-list 'auto-mode-alist '("\\.tsx?\\'" . typescript-tsx-mode))
    ;; (defun typescript-tsx-mode-fix-tree-sitter()
    ;;    (set (make-local-variable 'tree-sitter-hl-use-font-lock-keywords) nil))
    ;; (add-hook 'typescript-tsx-mode-hook #'typescript-tsx-mode-fix-tree-sitter)
    ;; (add-hook 'typescript-tsx-mode-hook #'tree-sitter-hl-mode)

    ;; (use-package tide
    ;;   :straight t
    ;;   :config
    ;;   (defun setup-tide-mode ()
    ;;     (interactive)
    ;;     (tide-setup)
    ;;     (flycheck-mode +1)
    ;;     (setq flycheck-check-syntax-automatically '(save mode-enabled))
    ;;     (eldoc-mode +1)
    ;;     (tide-hl-identifier-mode +1)
    ;;     ;; company is an optional dependency. You have to
    ;;     ;; install it separately via package-install
    ;;     ;; `M-x package-install [ret] company`
    ;;     (company-mode +1))

    ;;   ;; aligns annotation to the right hand side
    ;;   (setq company-tooltip-align-annotations t)

    ;;   ;; formats the buffer before saving
    ;;   (add-hook 'before-save-hook nil)

    ;;   (add-hook 'typescript-mode-hook #'setup-tide-mode))

    ;; (add-hook 'web-mode-hook
    ;;           (lambda ()
    ;;             (when (string-equal "tsx" (file-name-extension buffer-file-name))
    ;;               (setup-tide-mode))))
  (use-package apheleia
    :straight t
    :config
    (apheleia-global-mode +1)
    (setf (alist-get 'tsx-mode apheleia-mode-alist)
          '(prettier-typescript))
    (setf (alist-get 'tsx-ts-mode apheleia-mode-alist)
          '(prettier-typescript)))

  ;; (use-package eslint-fix
  ;;   :straight t
  ;;   :config
  ;;   (add-hook 'tsx-mode-hook #'eslint-fix-auto-mode)
  ;;   (add-hook 'tsx-ts-mode-hook #'eslint-fix-auto-mode))

  ;; typescript repl
  (use-package ts-comint
    :straight t
    :config
    (add-hook 'tsx-mode-hook
            (lambda ()
              (local-set-key (kbd "C-x C-e") 'ts-send-last-sexp)
              (local-set-key (kbd "C-M-x") 'ts-send-last-sexp-and-go)
              (local-set-key (kbd "C-c b") 'ts-send-buffer)
              (local-set-key (kbd "C-c C-b") 'ts-send-buffer-and-go)
              (local-set-key (kbd "C-c l") 'ts-load-file-and-go)))
    (add-hook 'tsx-ts-mode-hook
            (lambda ()
              (local-set-key (kbd "C-x C-e") 'ts-send-last-sexp)
              (local-set-key (kbd "C-M-x") 'ts-send-last-sexp-and-go)
              (local-set-key (kbd "C-c b") 'ts-send-buffer)
              (local-set-key (kbd "C-c C-b") 'ts-send-buffer-and-go)
              (local-set-key (kbd "C-c l") 'ts-load-file-and-go))))
#+END_SRC
***** TODO add something to automatically delete all unused imports

**** elisp
#+BEGIN_SRC emacs-lisp
  (use-package evil-lispy
    :straight t)
#+END_SRC

**** kotlin
#+BEGIN_SRC emacs-lisp
  (use-package kotlin-mode
    :straight t)
#+END_SRC

*** web programming
**** vue
***** COMMENT vue-mode
#+BEGIN_SRC emacs-lisp
  (use-package vue-mode
    :straight t
    :init (add-hook 'vue-mode-hook 'company-mode)
    (add-hook 'vue-mode-hook 'yas-minor-mode)
    :config
    (setq mmm-submode-decoration-level 0))
#+END_SRC
***** vue-html-mode

#+BEGIN_SRC emacs-lisp
  (use-package vue-html-mode
    :straight t)
#+END_SRC
***** vue lsp?
#+BEGIN_SRC emacs-lisp


#+end_src

#+BEGIN_SRC emacs-lisp
  (use-package vue-mode
    :straight t)
#+END_SRC

**** emmet

#+BEGIN_SRC emacs-lisp
  (use-package emmet-mode
    :straight t)
#+END_SRC

**** coffee?
**** web-mode
#+BEGIN_SRC emacs-lisp

  (use-package web-mode
    :straight t
    :init
    (add-to-list 'auto-mode-alist '("\\.phtml\\'" . web-mode))
    (add-to-list 'auto-mode-alist '("\\.tpl\\.php\\'" . web-mode))
    (add-to-list 'auto-mode-alist '("\\.[agj]sp\\'" . web-mode))
    (add-to-list 'auto-mode-alist '("\\.as[cp]x\\'" . web-mode))
    (add-to-list 'auto-mode-alist '("\\.erb\\'" . web-mode))
    (add-to-list 'auto-mode-alist '("\\.mustache\\'" . web-mode))
    (add-to-list 'auto-mode-alist '("\\.djhtml\\'" . web-mode))
    (add-to-list 'auto-mode-alist '("\\.vue\\'" . web-mode))
    (add-hook 'editorconfig-custom-hooks
              (lambda (hash) (setq web-mode-block-padding 0)))
    (add-hook 'web-mode-hook 'company-mode)
    ;; (add-hook 'web-mode-hook 'yas-minor-mode)
    :config
    (setq web-mode-enable-auto-indentation nil)
    (setq web-mode-content-types-alist '(("jsx" . "\\.js[x]?\\'"))))

#+END_SRC

*** COMMENT LaTeX
#+BEGIN_SRC emacs-lisp
  ;; (use-package tex			;
  ;;   :defer t
  ;;   :straight auctex
  ;;   :config
  ;;   (setq TeX-auto-save t))
  ;; (use-package auctex
  ;; :straight t)

#+END_SRC

** Tabs
#+BEGIN_SRC emacs-lisp
  ;; abolish tabs
  (setq-default indent-tabs-mode nil)
  (setq tab-stop-list (number-sequence 2 120 2))
#+END_SRC

** TODO yas for inserting emacs lisp begin src
minor mode not set up?
** Subwords
Emacs treats camelCase strings as a single word by default, this changes said behaviour.
#+BEGIN_SRC emacs-lisp
  (global-subword-mode 1)
#+END_SRC

** Electric
autocomplete pairs
#+BEGIN_SRC emacs-lisp
  (setq electric-pair-pairs '(
                              (?\{ . ?\})
                              (?\( . ?\))
                              (?\[ . ?\])
                              (?\" . ?\")))
#+END_SRC

And now to enable it
#+BEGIN_SRC emacs-lisp
  (electric-pair-mode t)
#+END_SRC
** Rainbow
shows color of hex color
#+BEGIN_SRC emacs-lisp
  (use-package rainbow-mode
    :straight t
    :init
    (add-hook 'prog-mode-hook 'rainbow-mode))
#+END_SRC

** Show parens
highlight matching paren
#+BEGIN_SRC emacs-lisp
  (show-paren-mode 1)
#+END_SRC
** Rainbow delimiters
Colors parentheses and other delimiters depending on their depth
#+BEGIN_SRC emacs-lisp
  (use-package rainbow-delimiters
    :straight t
    :init
    (add-hook 'prog-mode-hook #'rainbow-delimiters-mode))
#+END_SRC

** Expand region
grow region over levels of semantic objects.
#+BEGIN_SRC emacs-lisp
  (use-package expand-region
    :straight t
    :bind ("C-M-q" . er/expand-region))
#+END_SRC

** Hungry deletion
Backspace or Delete will get rid of all whitespace until the next non-whitespace character is encountered.
#+BEGIN_SRC emacs-lisp
  (use-package hungry-delete
    :straight t
    :config
    (global-hungry-delete-mode))
#+END_SRC

** line numbers
Relative line numbers
#+BEGIN_SRC emacs-lisp
  (use-package linum-relative
    :straight t
    :config
    (setq linum-relative-current-symbol "")
    (add-hook 'prog-mode-hook 'linum-relative-mode))
#+END_SRC

** add eslint compilation buffer regex
#+begin_src emacs-lisp
  (use-package compile-eslint
    :straight (compile-eslint :type git :host github :repo "Fuco1/compile-eslint") 
    :config (push 'eslint compilation-error-regexp-alist)) ;; optional
#+end_src
** add color to compilation buffers
#+begin_src emacs-lisp
  (defun my/ansi-colorize-buffer ()
    (let ((buffer-read-only nil))
      (ansi-color-apply-on-region (point-min) (point-max))))
  (add-hook 'compilation-filter-hook 'my/ansi-colorize-buffer)

#+end_src
** COMMENT editorconfig
#+BEGIN_SRC emacs-lisp
  (use-package editorconfig
    :straight t
    :config
    (editorconfig-mode 1))
  :lighter
#+END_SRC
* (C-c lowercase)
** COMMENT Mark Multiple
#+BEGIN_SRC emacs-lisp
  (use-package mark-multiple
    :straight t
    :bind ("C-c q" . 'mark-next-like-this))
#+END_SRC
** media (d)
*** management (m)
#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "C-c d m") 'emms)
#+END_SRC
*** add (a)
**** from dired (d)
#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "C-c a d") 'emms-add-dired)
#+END_SRC
**** TODO from search (s)
**** from find-file (f)
#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "C-c a f") 'emms-add-find)
#+END_SRC
*** streams (s)
#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "C-c d s") 'emms-streams)
#+END_SRC
*** next (n)
#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "C-c d n") 'emms-next)
#+END_SRC
*** previous (p)
#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "C-c d p") 'emms-previous)
#+END_SRC
*** pause (SPC)
#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "C-c d SPC") 'emms-pause)
#+END_SRC

** framing (f)
*** TODO maybe something like persp mode?
** web (w)
*** wowser (w)
#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "C-c w w") 'eww)
#+END_SRC
** insert (i)
*** TODO insert unicode (u)
** capture/journal (j)
#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "C-c j") 'org-capture)
#+END_SRC



